一、redis持久化
  持久化的功能：Redis 是内存数据库，数据都是存储在内存中。
  为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次 Redis 重启时，利用持久化文件实现数据恢复。
  除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。
  Redis 持久化分为 RDB 持久化和 AOF 持久化：
    前者将当前数据保存到硬盘
    后者则是将每次执行的写命令保存到硬盘（类似于 MySQL 的 binlog）
  由于 AOF 持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此 AOF 是目前主流的持久化方式，不过 RDB 持久化仍然有其用武之地。
  (1)RDB
  RDB 持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是 RDB；当 Redis 重新启动时，可以读取快照文件恢复数据。
  RDB 持久化的触发分为手动触发和自动触发两种：
    手动触发
    自动触发
  手动触发：save 命令和 bgsave 命令都可以生成 RDB 文件。
  save 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在 Redis 服务器阻塞期间，服务器不能处理任何命令请求。
  而 bgsave 命令会创建一个子进程，由子进程来负责创建 RDB 文件，父进程(即 Redis 主进程)则继续处理请求。
  此外，在自动触发 RDB 持久化时，Redis 也会选择 bgsave 而不是 save 来进行持久化；下面介绍自动触发 RDB 持久化的条件。
  自动触发：最常见的情况是在配置文件中通过 save m n，指定当 m 秒内发生 n 次变化时，会触发 bgsave。
  其中 save 900 1 的含义是：当时间到 900 秒时，如果 Redis 数据发生了至少 1 次变化，则执行 bgsave。
  save 300 10 和 save 60 10000 同理，当三个 save 条件满足任意一个时，都会引起 bgsave 的调用。
  
  save m n 的实现原理：Redis 的 save m n，是通过 serverCron 函数、dirty 计数器和 lastsave 时间戳来实现的。
  serverCron 是 Redis 服务器的周期性操作函数，默认每隔 100ms 执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行 bgsave。
  dirty 计数器是 Redis 服务器维持的一个状态，记录了上一次执行 bgsave/save 命令后，服务器状态进行了多少次修改(包括增删改)；而当 save/bgsave 执行完成后，会将 dirty 重新置为 0。
  lastsave 时间戳也是 Redis 服务器维持的一个状态，记录的是上一次成功执行 save/bgsave 的时间。
  save m n 的原理如下：每隔 100ms，执行 serverCron 函数；在 serverCron 函数中，遍历 save m n 配置的保存条件，只要有一个条件满足，就进行 bgsave。
  
  对于每一个 save m n 条件，只有下面两条同时满足时才算满足：
    当前时间-lastsave > m
    dirty >= n
    
  RDB 文件是经过压缩的二进制文件;Redis 默认采用 LZF 算法对 RDB 文件进行压缩。虽然压缩耗时，但是可以大大减小 RDB 文件的体积，因此压缩默认开启；
  需要注意的是，RDB 文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20 字节)时才会进行。
  
  DB 文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于 AOF 的优先级更高，因此当 AOF 开启时，Redis 会优先载入 AOF 文件来恢复数据。
  只有当 AOF 关闭时，才会在 Redis 服务器启动时检测 RDB 文件，并自动载入。服务器载入 RDB 文件期间处于阻塞状态，直到载入完成为止。
  
  (2)AOF
  
